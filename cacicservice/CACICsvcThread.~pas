(*
  A Windows NT Service Thread
  ===========================

  Author          Kim Sandell
                  Email: kim.sandell@nsftele.com
*)
unit CACICsvcThread;

interface

uses
  Windows, Messages, SysUtils, Classes, StrUtils;

var strHomeDrive,
    strCacicDir   : String;

type
  TNTServiceThread = Class(TThread)
  private
    { Private declarations }
    function  HomeDrive : string;
    function  GetValorChaveRegIni(p_Secao, p_Chave, p_File : String): String;
    function  GetAppPath: String;
    procedure doSaveLog(Msg : String);
    function  CreateProcessSimple(sExecutableFilePath : string ) : String;
  Public
    { Public declarations }
    Interval              : Integer;

    Procedure Execute; Override;
  Published
    { Published declarations }
  End;

implementation

{ TNTServiceThread }
// Funções Auxiliares
function TNTServiceThread.GetValorChaveRegIni(p_Secao, p_Chave, p_File : String): String;
//Para buscar do Arquivo INI...
// Marreta devido a limitações do KERNEL w9x no tratamento de arquivos texto e suas seções
//function GetValorChaveRegIni(p_SectionName, p_KeyName, p_IniFileName : String) : String;
var
  FileText : TStringList;
  i, j, v_Size_Section, v_Size_Key : integer;
  v_SectionName, v_KeyName : string;
  begin
//doSaveLog('GetVCRini: Secao: '+p_Secao+' Chave: '+p_Chave+' File: '+p_File);
    Result := '';
    v_SectionName := '[' + p_Secao + ']';
    v_Size_Section := strLen(PChar(v_SectionName));
    v_KeyName := p_Chave + '=';
    v_Size_Key     := strLen(PChar(v_KeyName));
    FileText := TStringList.Create;
    try
      FileText.LoadFromFile(p_File);
      For i := 0 To FileText.Count - 1 Do
        Begin
          if (LowerCase(Trim(PChar(Copy(FileText[i],1,v_Size_Section)))) = LowerCase(Trim(PChar(v_SectionName)))) then
            Begin
              For j := i to FileText.Count - 1 Do
                Begin
                  if (LowerCase(Trim(PChar(Copy(FileText[j],1,v_Size_Key)))) = LowerCase(Trim(PChar(v_KeyName)))) then
                    Begin
                      Result := PChar(Copy(FileText[j],v_Size_Key + 1,strLen(PChar(FileText[j]))-v_Size_Key));
                      Break;
                    End;
                End;
            End;
          if (Result <> '') then break;
        End;
    finally
      FileText.Free;
    end;
  end;

function TNTServiceThread.GetAppPath: String;
Var
  Test : String;
  Res  : Longint;
  CurSize : Longint;
begin
  CurSize := 1024;
  SetLength(Test, CurSize);
  Res := GetModuleFilename(GetModuleHandle(nil), PChar(test), CurSize);
  If (res > curSize) then
  begin
    CurSize := res + 10;
    SetLength(Test, CurSize);
    Res := GetModuleFilename(GetModuleHandle(nil), PChar(test), CurSize);
  end;
  Setlength(Test, Res);
  test := ExtractFileDir(Test);
  if (test[Length(test)] = '\') or (test[Length(test)]='/') then
      SetLength(Test, Length(test) - 1);
  Result := test;
end;

function TNTServiceThread.HomeDrive : string;
var WinDir : array [0..144] of char;
begin
  GetWindowsDirectory (WinDir, 144);
  Result := StrPas (WinDir);
end;

procedure TNTServiceThread.doSaveLog(Msg : String);
var fLog: textfile;
begin
  AssignFile(fLog, strHomeDrive + 'CACICsvc.log');
  if FileExists(strHomeDrive + 'CACICsvc.log') then
    Append(fLog)
  else
    Rewrite(fLog);
  Writeln(fLog,FormatDateTime('dd/mm hh:nn:ss ', Now) + '[CACICsvc] : ' +msg);
  CloseFile(fLog);
End;

function TNTServiceThread.CreateProcessSimple(sExecutableFilePath : string ) : string;
var
  pi: TProcessInformation;
  si: TStartupInfo;
begin
  FillMemory( @si, sizeof( si ), 0 );
  si.cb := sizeof( si );

  CreateProcess(
    Nil,
    PChar( sExecutableFilePath ),
    Nil, Nil, False,
    NORMAL_PRIORITY_CLASS, Nil, Nil,
    si, pi );

  // "after calling code" such as
  // the code to wait until the
  // process is done should go here

  CloseHandle( pi.hProcess );
  CloseHandle( pi.hThread );
end;

procedure TNTServiceThread.Execute;
begin
  strHomeDrive := MidStr(HomeDrive,1,3); //x:\
  doSaveLog('strHomeDrive: '+strHomeDrive);

  strCacicDir  :=  strHomeDrive + GetValorChaveRegIni('Cacic2', 'cacic_dir', GetAppPath + '\chksis.ini');
  doSaveLog('strCacicDir: '+strCacicDir);

  // Executo o CHKsis, verificando a estrutura do sistema
  Try
    CreateProcessSimple(PChar(HomeDrive + '\chksis.exe'));
  Except
  End;

  While not (FileExists(strCacicDir + '\cacic2.exe')) do
    Sleep(5000); // Espero 5 segundos...

  // Executo o Agente Principal do CACIC
  Try
  doSaveLog('Executarei "'+strCacicDir + '\cacic2.exe"');
    CreateProcessSimple(PChar(strCacicDir + '\cacic2.exe'));
  Except
  End;

  While not Terminated do
    Sleep(250);

     {
     // Do NOT free on termination - The Serivce frees the Thread
     FreeOnTerminate := False;

     // Set Interval
     TimeOut := Interval * 4;

     // Main Loop
     Try
        While Not Terminated do
        Begin
             // Decrement timeout
             Dec( TimeOut );

             If (TimeOut=0) then
             Begin
                  // Reset timer
                  TimeOut := Interval * 4;

                  // Beep once per x seconds
                  Beep;
             End;
             // Wait 1/4th of a second
             Sleep(250);
        End;
     Except
        On E:Exception do ; // TODO: Exception logging...
     End;
     // Terminate the Thread - This signals Terminated=True
     Terminate;
     }
end;

end.
